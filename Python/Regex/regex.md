## Основи regex у Python
Для роботи із регулярними виразами в Python потрібно підключити модуль `re` — це вбудований інструмент Python для роботи з регулярними виразами.

```python
import re
```

### У модуля 're' є ряд основних методів
1. **`re.search(pattern, string)`** — шукає перше входження шаблону в рядку, повертає об’єкт Match або None.
2. **`re.match(pattern, string)`** — перевіряє, чи рядок починається з шаблону (лише з початку).
3. **`re.findall(pattern, string)`** — повертає список усіх неперекриваючихся збігів.
4. **`re.finditer(pattern, string)`** — повертає ітератор об’єктів Match для всіх збігів.
5. **`re.sub(pattern, replacement, string)`** — замінює збіги на вказаний текст.
6. **`re.subn(pattern, replacement, string)`** — те саме, що `re.sub`, але повертає кортеж (новий рядок, кількість замін).
7. **`re.split(pattern, string)`** — розбиває рядок за шаблоном.
8. **`re.compile(pattern)`** — компілює шаблон для повторного використання.

---

## Символи та конструкції регулярних виразів
### 1. Основні метасимволи
- `.` — будь-який символ, крім нового рядка.
- `^` — початок рядка.
- `$` — кінець рядка.
- `*` — 0 або більше повторень.
- `+` — 1 або більше повторень.
- `?` — 0 або 1 повторення.
- `{n}` — точно n повторень.
- `{n,}` — n або більше повторень.
- `{n,m}` — від n до m повторень.
- `|` — логічне "або".
- `()` — групування.

### 2. Набори символів
- `[abc]` — один із символів a, b або c.
- `[a-z]` — будь-яка мала літера.
- `[A-Z]` — будь-яка велика літера.
- `[0-9]` — будь-яка цифра.
- `[^abc]` — будь-який символ, крім a, b, c.

### 3. Спеціальні послідовності
- `\d` — цифра (еквівалент `[0-9]`).
- `\D` — не цифра (еквівалент `[^0-9]`).
- `\w` — буквено-цифровий символ або підкреслення (еквівалент `[a-zA-Z0-9_]`).
- `\W` — не буквено-цифровий символ (еквівалент `[^a-zA-Z0-9_]`).
- `\s` — пробільний символ (пробіл, таб, новий рядок).
- `\S` — не пробільний символ.
- `\b` — межа слова.
- `\B` — не межа слова.

### 4. Екранування
- `\` — екранує спеціальні символи (наприклад, `\.` — крапка як символ, а не метасимвол).

### 5. "Жадібність" та "Ледачість"
Існують моменти коли потрібно для кванторів поставити завдання вибирати мінімально можливу кількість символів або навпаки максимальну, для цього в регулярних виразаї існує поняття **"жадібних"** та **"ледачих"** кванторів:
- `*`, `+`, `{n,m}` за замовчуванням "жадібні" (захоплюють максимум символів).
- Додайте `?` (наприклад, `*?`, `+?`), щоб зробити їх "ледачими" (захоплюють мінімум).

### 6. Групи та зворотні посилання
- `(...)` — створює групу, яку можна отримати через `.group(n)`.
- `\1`, `\2` — зворотні посилання на попередні групи в шаблоні.

### 7. Прапорці (flags)
Додаються до методів як аргумент `flags`:
- `re.IGNORECASE` (`re.I`) — ігнорує регістр.
- `re.MULTILINE` (`re.M`) — робить `^` і `$` працювати для кожного рядка.
- `re.DOTALL` (`re.S`) — робить `.` включати новий рядок.

---

## Приклади найчастішого використання

### 1. Пошук і витягнення email-адрес
```python
text = "Зв’яжіться зі мною: user@example.com або test.email@domain.ua"
emails = re.findall(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', text)
print(emails)  # ['user@example.com', 'test.email@domain.ua']
```

### 2. Перевірка формату номера телефону
```python
phone = "+380 (95) 123-45-67"
if re.match(r'^\+380\s?\(\d{2}\)\s?\d{3}-\d{2}-\d{2}$', phone):
    print("Номер валідний!")
else:
    print("Номер некоректний.")
# Виведе: Номер валідний!
```

### 3. Розбиття тексту за кількома роздільниками
```python
text = "яблуко, груша; апельсин - мандарин"
fruits = re.split(r'[,;\s-]+', text)
print(fruits)  # ['яблуко', 'груша', 'апельсин', 'мандарин']
```

### 4. Заміна всіх цифр на слово "NUMBER"
```python
text = "У мене 5 яблук і 12 груш."
result = re.sub(r'\d+', 'NUMBER', text)
print(result)  # У мене NUMBER яблук і NUMBER груш.
```

### 5. Витягнення всіх слів, що починаються з великої літери
```python
text = "Київ прекрасний, але Харків також чудовий."
capitals = re.findall(r'\b[A-ZА-Я][a-zа-я]*\b', text)
print(capitals)  # ['Київ', 'Харків']
```

### 6. Використання груп для розбору дати
```python
date = "Дата: 2025-03-26"
match = re.search(r'(\d{4})-(\d{2})-(\d{2})', date)
if match:
    year, month, day = match.groups()
    print(f"Рік: {year}, Місяць: {month}, День: {day}")
# Виведе: Рік: 2025, Місяць: 03, День: 26
```

### 7. Пошук HTML-тегів (з ледачим режимом)
```python
html = "<p>Текст</p><div>Інший текст</div>"
tags = re.findall(r'<.*?>', html)
print(tags)  # ['<p>', '</p>', '<div>', '</div>']
```

### 8. Використання зворотних посилань для пошуку повторів
```python
text = "Слово слово СЛОВО слово"
doubles = re.findall(r'\b(\w+)\s+\1\b', text, re.IGNORECASE)
print(doubles)  # ['слово']
```

### 9. Компіляція шаблону для повторного використання
```python
pattern = re.compile(r'\d+')
text = "У 2025 році буде 12 місяців."
numbers = pattern.findall(text)
print(numbers)  # ['2025', '12']
```

---

## Поради для роботи з regex
1. **Тестуйте шаблони**: Використовуйте [regex101.com](https://regex101.com/) для відлагодження.
2. **Уникайте надмірної складності**: Якщо шаблон стає занадто складним, подумайте про розбиття задачі на кілька кроків або дивіться можливість скоротити шаблон використовуючи групи.
3. **Оптимізація**: Для великих текстів використовуйте `re.compile`, щоб уникнути повторного парсингу шаблону.